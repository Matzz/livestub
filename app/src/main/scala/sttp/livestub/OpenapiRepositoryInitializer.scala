package sttp.livestub

import cats.data.NonEmptyList
import cats.syntax.all._
import cats.effect.IO
import io.chrisdavenport.log4cats.Logger
import sttp.livestub.api.{MethodValue, RequestPathAndQuery, RequestStub, Response}
import sttp.livestub.openapi.OpenapiModels.{OpenapiDocument, OpenapiResponseContent, ResponseStatusCode}
import sttp.model.{MediaType, StatusCode}

class OpenapiRepositoryInitializer(generator: RandomValueGenerator) extends FLogger {
  def apply(repository: ListingStubRepositoryDecorator, spec: OpenapiDocument): IO[ListingStubRepositoryDecorator] = {
    spec.paths
      .flatMap { path =>
        path.methods.flatMap { method =>
          method.responses.headOption.map { firstResponse =>
            val stub = RequestStub(
              MethodValue.FixedMethod(method.methodType),
              RequestPathAndQuery.fromString(path.url.replaceAll("\\{\\w+\\}", "*"))
            )
            val autoGeneratedObjects = firstResponse.content
              .collectFirst { case OpenapiResponseContent(MediaType.ApplicationJson, schema) => schema }
              .traverse(generator.nextRandom)
            val responseStatusCode = firstResponse.code match {
              case ResponseStatusCode.Fixed(code) => code
              case ResponseStatusCode.Default     => StatusCode.Ok
            }
            autoGeneratedObjects match {
              case Left(reason) =>
                Logger[IO].warn(s"Couldn't generate response object for $stub because of $reason") >>
                  repository.put(
                    stub,
                    NonEmptyList.one(Response(None, responseStatusCode))
                  )
              case Right(value) =>
                Logger[IO].info(s"Stubbing $stub") >>
                  repository.put(
                    stub,
                    NonEmptyList.one(Response(value, responseStatusCode))
                  )
            }
          }
        }
      }
      .sequence
      .as(repository)
  }
}
